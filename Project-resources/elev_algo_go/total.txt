THE FOLLOWING IS THE CODE WRITTEN/IMPLEMENTED SO FAR:
Let ~ denote the root directory of the project (same dir as main.go is present in).


Content of ~/elevator_io/elevator_io_types.Go:

package elevator_io

// Dirn represents the elevator's direction.
type Dirn int

// Enumeration for elevator directions.
const (
	D_Down Dirn = -1
	D_Stop Dirn = 0
	D_Up   Dirn = 1
)

// Button represents the types of buttons in the elevator.
type Button int

// Enumeration for elevator button types.
const (
	B_HallUp Button = iota
	B_HallDown
	B_Cab
)

// Constants for the number of floors and buttons.
const (
	N_Floors  = 4
	N_Buttons = 3
)

// ElevInputDevice represents the structure for elevator input devices.
type ElevInputDevice struct {
	FloorSensor   func() int
	RequestButton func(int, Button) int
	StopButton    func() int
	Obstruction   func() int
}

// ElevOutputDevice represents the structure for elevator output devices.
type ElevOutputDevice struct {
	FloorIndicator     func(int)
	RequestButtonLight func(int, Button, int)
	DoorLight          func(int)
	StopButtonLight    func(int)
	MotorDirection     func(Dirn)
}



Content of ~/elevio/elevator_io.go:

package elevio

// Same as "driver-go"

import (
	"fmt"
	"net"
	"sync"
	"time"
)

const _pollRate = 20 * time.Millisecond

var _initialized bool = false
var _numFloors int = 4
var _mtx sync.Mutex
var _conn net.Conn

type MotorDirection int

const (
	MD_Up   MotorDirection = 1
	MD_Down                = -1
	MD_Stop                = 0
)

type ButtonType int

const (
	BT_HallUp   ButtonType = 0
	BT_HallDown            = 1
	BT_Cab                 = 2
)

type ButtonEvent struct {
	Floor  int
	Button ButtonType
}

func Init(addr string, numFloors int) {
	if _initialized {
		fmt.Println("Driver already initialized!")
		return
	}
	_numFloors = numFloors
	_mtx = sync.Mutex{}
	var err error
	_conn, err = net.Dial("tcp", addr)
	if err != nil {
		panic(err.Error())
	}
	_initialized = true
}

func SetMotorDirection(dir MotorDirection) {
	write([4]byte{1, byte(dir), 0, 0})
}

func SetButtonLamp(button ButtonType, floor int, value bool) {
	write([4]byte{2, byte(button), byte(floor), toByte(value)})
}

func SetFloorIndicator(floor int) {
	write([4]byte{3, byte(floor), 0, 0})
}

func SetDoorOpenLamp(value bool) {
	write([4]byte{4, toByte(value), 0, 0})
}

func SetStopLamp(value bool) {
	write([4]byte{5, toByte(value), 0, 0})
}

func PollButtons(receiver chan<- ButtonEvent) {
	prev := make([][3]bool, _numFloors)
	for {
		time.Sleep(_pollRate)
		for f := 0; f < _numFloors; f++ {
			for b := ButtonType(0); b < 3; b++ {
				v := GetButton(b, f)
				if v != prev[f][b] && v != false {
					receiver <- ButtonEvent{f, ButtonType(b)}
				}
				prev[f][b] = v
			}
		}
	}
}

func PollFloorSensor(receiver chan<- int) {
	prev := -1
	for {
		time.Sleep(_pollRate)
		v := GetFloor()
		if v != prev && v != -1 {
			receiver <- v
		}
		prev = v
	}
}

func PollStopButton(receiver chan<- bool) {
	prev := false
	for {
		time.Sleep(_pollRate)
		v := GetStop()
		if v != prev {
			receiver <- v
		}
		prev = v
	}
}

func PollObstructionSwitch(receiver chan<- bool) {
	prev := false
	for {
		time.Sleep(_pollRate)
		v := GetObstruction()
		if v != prev {
			receiver <- v
		}
		prev = v
	}
}

func GetButton(button ButtonType, floor int) bool {
	a := read([4]byte{6, byte(button), byte(floor), 0})
	return toBool(a[1])
}

func GetFloor() int {
	a := read([4]byte{7, 0, 0, 0})
	if a[1] != 0 {
		return int(a[2])
	} else {
		return -1
	}
}

func GetStop() bool {
	a := read([4]byte{8, 0, 0, 0})
	return toBool(a[1])
}

func GetObstruction() bool {
	a := read([4]byte{9, 0, 0, 0})
	return toBool(a[1])
}

func read(in [4]byte) [4]byte {
	_mtx.Lock()
	defer _mtx.Unlock()

	_, err := _conn.Write(in[:])
	if err != nil {
		panic("Lost connection to Elevator Server")
	}

	var out [4]byte
	_, err = _conn.Read(out[:])
	if err != nil {
		panic("Lost connection to Elevator Server")
	}

	return out
}

func write(in [4]byte) {
	_mtx.Lock()
	defer _mtx.Unlock()

	_, err := _conn.Write(in[:])
	if err != nil {
		panic("Lost connection to Elevator Server")
	}
}

func toByte(a bool) byte {
	var b byte = 0
	if a {
		b = 1
	}
	return b
}

func toBool(a byte) bool {
	var b bool = false
	if a != 0 {
		b = true
	}
	return b
}




Content of ~/timer/timer.go:

package timer

import (
	"time"
)

var timer *time.Timer
var timerActive bool

func timer_start(duration float64) {
	timer = time.NewTimer(time.Duration(duration) * time.Second)
	timerActive = true
}

func timer_stop() {
	if timer != nil {
		timer.Stop()
	}
	timerActive = false
}

func timer_timedOut() bool {
	if !timerActive {
		return false
	}
	select {
	case <-timer.C:
		timerActive = false
		return true
	default:
		return false
	}
}




Content of ~/fsm/fsm.go:

package fsm

import (
	"elevio"
	"fmt"
	"time"
)

// ElevatorState represents the state of the elevator.
type ElevatorState struct {
	Floor     int
	Dir       elevio.MotorDirection
	Behaviour ElevatorBehaviour
	Requests  [elevio.N_Floors][elevio.N_Buttons]bool
	Config    ElevatorConfig
}

// ElevatorBehaviour represents the behaviour of the elevator.
type ElevatorBehaviour int

const (
	EB_Idle ElevatorBehaviour = iota
	EB_Moving
	EB_DoorOpen
)

// ElevatorConfig holds configuration for the elevator.
type ElevatorConfig struct {
	DoorOpenDuration time.Duration
}

var elevator ElevatorState
var outputDevice elevio.ElevOutputDevice

func init() {
	// Initialize the elevator state.
	elevator = ElevatorState{
		Floor:     -1,
		Dir:       elevio.MD_Stop,
		Behaviour: EB_Idle,
		Config: ElevatorConfig{
			DoorOpenDuration: 3 * time.Second,
		},
	}
	outputDevice = elevio.GetOutputDevice()
}

func fsm_onInitBetweenFloors() {
	outputDevice.SetMotorDirection(elevio.MD_Down)
	elevator.Dir = elevio.MD_Down
	elevator.Behaviour = EB_Moving
}

func fsm_onRequestButtonPress(btnFloor int, btnType elevio.ButtonType) {
	fmt.Printf("\nRequest button pressed at floor %d, button %v\n", btnFloor, btnType)
	elevator.Requests[btnFloor][btnType] = true
	// Additional logic based on elevator state...
}

func fsm_onFloorArrival(newFloor int) {
	fmt.Printf("\nArrived at floor %d\n", newFloor)
	elevator.Floor = newFloor
	outputDevice.SetFloorIndicator(newFloor)
	// Additional logic based on elevator state...
}

func fsm_onDoorTimeout() {
	fmt.Println("\nDoor timeout")
	// Additional logic based on elevator state...
}




Content of ~/requests/requests.go:

package requests

import (
	"elevio"
	"fsm"
)

func RequestsAbove(e fsm.ElevatorState) bool {
	for f := e.Floor + 1; f < elevio.N_Floors; f++ {
		for btn := range e.Requests[f] {
			if e.Requests[f][btn] {
				return true
			}
		}
	}
	return false
}

func RequestsBelow(e fsm.ElevatorState) bool {
	for f := 0; f < e.Floor; f++ {
		for btn := range e.Requests[f] {
			if e.Requests[f][btn] {
				return true
			}
		}
	}
	return false
}

func RequestsHere(e fsm.ElevatorState) bool {
	for btn := range e.Requests[e.Floor] {
		if e.Requests[e.Floor][btn] {
			return true
		}
	}
	return false
}

func ChooseDirection(e fsm.ElevatorState) (elevio.MotorDirection, fsm.ElevatorBehaviour) {
	switch e.Dir {
	case elevio.MD_Up:
		if RequestsAbove(e) {
			return elevio.MD_Up, fsm.EB_Moving
		} else if RequestsHere(e) {
			return elevio.MD_Down, fsm.EB_DoorOpen
		} else if RequestsBelow(e) {
			return elevio.MD_Down, fsm.EB_Moving
		}
	case elevio.MD_Down:
		if RequestsBelow(e) {
			return elevio.MD_Down, fsm.EB_Moving
		} else if RequestsHere(e) {
			return elevio.MD_Up, fsm.EB_DoorOpen
		} else if RequestsAbove(e) {
			return elevio.MD_Up, fsm.EB_Moving
		}
	}
	return elevio.MD_Stop, fsm.EB_Idle
}

func ShouldStop(e fsm.ElevatorState) bool {
	switch e.Dir {
	case elevio.MD_Down:
		return e.Requests[e.Floor][elevio.B_HallDown] || e.Requests[e.Floor][elevio.B_Cab] || !RequestsBelow(e)
	case elevio.MD_Up:
		return e.Requests[e.Floor][elevio.B_HallUp] || e.Requests[e.Floor][elevio.B_Cab] || !RequestsAbove(e)
	default:
		return true
	}
}

func ShouldClearImmediately(e fsm.ElevatorState, btnFloor int, btnType elevio.ButtonType) bool {
	// Assuming you have a configuration for ClearRequestVariant
	switch e.Config.ClearRequestVariant {
	case ClearAll:
		return e.Floor == btnFloor
	case ClearInDirn:
		return e.Floor == btnFloor && ((e.Dir == elevio.MD_Up && btnType == elevio.B_HallUp) ||
			(e.Dir == elevio.MD_Down && btnType == elevio.B_HallDown) ||
			e.Dir == elevio.MD_Stop || btnType == elevio.B_Cab)
	default:
		return false
	}
}

func ClearAtCurrentFloor(e fsm.ElevatorState) fsm.ElevatorState {
	// Implement logic based on e.Config.ClearRequestVariant
	// Update e.Requests accordingly
	return e
}



Content of ~/main.go:

package main

import (
	"elevio"
	"fsm"
	"time"
)

const inputPollRate = 25 * time.Millisecond

func main() {
	elevio.Init("localhost:15657", elevio.N_Floors)

	// Initialize the elevator to a known state
	if elevio.GetFloor() == -1 {
		fsm.FsmOnInitBetweenFloors()
	}

	// Main loop
	for {
		// Poll request buttons
		for f := 0; f < elevio.N_Floors; f++ {
			for b := elevio.BT_HallUp; b <= elevio.BT_Cab; b++ {
				if v := elevio.GetButton(b, f); v {
					fsm.FsmOnRequestButtonPress(f, b)
				}
			}
		}

		// Poll floor sensor
		if f := elevio.GetFloor(); f != -1 {
			fsm.FsmOnFloorArrival(f)
		}

		// Handle door timeout
		if timer.TimerTimedOut() {
			timer.TimerStop()
			fsm.FsmOnDoorTimeout()
		}

		time.Sleep(inputPollRate)
	}
}
